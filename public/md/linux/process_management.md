# 프로세스 관리

Linux 시스템에서 프로세스는 실행 중인 프로그램의 인스턴스입니다. 프로세스 관리는 시스템의 자원 사용을 모니터링하고, 불필요하거나 문제가 있는 프로세스를 제어하는 데 필수적입니다.

## 1. 프로세스 확인 명령어

### `ps` (process status)
현재 실행 중인 프로세스의 스냅샷을 보여줍니다.
- `ps aux`: 모든 사용자의 모든 프로세스를 상세하게 보여줍니다.
    - `a`: 터미널과 연결된 모든 프로세스
    - `u`: 사용자 기반 형식으로 출력
    - `x`: 터미널과 연결되지 않은 프로세스 포함
    - **예시**: `ps aux | grep nginx` (Nginx 관련 프로세스 검색)
```bash
$ ps aux | grep nginx
root      1234  0.0  0.1  123456 1234 ?        Ss   Jul28   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;
www-data  1235  0.0  0.1  123456 1234 ?        S    Jul28   0:00 nginx: worker process
www-data  1236  0.0  0.1  123456 1234 ?        S    Jul28   0:00 nginx: worker process
user      5678  0.0  0.0   9876  789 pts/0    S+   10:30   0:00 grep nginx
```
- `ps -ef`: 모든 프로세스를 트리 형태로 보여줍니다. (BSD/System V 스타일)
    - `e`: 모든 프로세스
    - `f`: 풀 포맷 (Full format)
    - **예시**: `ps -ef | less` (모든 프로세스를 페이지 단위로 확인)

**`ps aux` 출력 컬럼 설명:**
- `USER`: 프로세스를 실행한 사용자
- `PID`: 프로세스 ID (고유 식별자)
- `%CPU`: CPU 사용률
- `%MEM`: 메모리 사용률
- `VSZ`: 가상 메모리 크기 (KB)
- `RSS`: 실제 사용 중인 물리 메모리 크기 (KB)
- `TTY`: 프로세스가 실행된 터미널
- `STAT`: 프로세스 상태 (R: 실행 중, S: 대기, Z: 좀비, T: 정지 등)
- `START`: 프로세스 시작 시간
- `TIME`: 프로세스가 사용한 CPU 시간
- `COMMAND`: 실행된 명령어

### `top`
실시간으로 시스템의 프로세스 상태를 모니터링합니다. CPU, 메모리 사용량, 각 프로세스의 자원 점유율 등을 동적으로 업데이트하여 보여줍니다.
- `top` 실행 후:
    - `q`: 종료
    - `k`: 프로세스 종료 (PID 입력)
    - `r`: 프로세스 우선순위 변경 (PID, NICE 값 입력)
    - `M`: 메모리 사용량 기준으로 정렬
    - `P`: CPU 사용량 기준으로 정렬
    - `T`: 실행 시간 기준으로 정렬

### `htop`
`top`의 개선된 버전으로, 더 사용자 친화적인 인터페이스와 추가 기능을 제공합니다. (설치 필요: `sudo apt install htop` 또는 `sudo dnf install htop`)
- **예시**: `htop` (실시간 시스템 모니터링)

### `pstree` (process tree)
프로세스들을 부모-자식 관계의 트리 형태로 보여줍니다.
- `pstree`: 현재 시스템의 프로세스 트리를 보여줍니다.
- **예시**: `pstree` (프로세스 트리 구조 확인)
```
systemd─┬─apache2───┬─apache2
        │           └─apache2
        ├─sshd───┬─sshd───┬─bash───pstree
        │        │        └─sftp-server
        │        └─sshd
        └─(sd-pam)
```
- `pstree -p`: PID를 함께 보여줍니다.
- `pstree -u`: 사용자 이름을 함께 보여줍니다.

## 2. 프로세스 제어 명령어

### `kill`
프로세스에 시그널을 보내어 제어합니다. 기본 시그널은 `TERM` (종료)입니다.
- `kill [PID]`: 지정된 PID의 프로세스에 종료 시그널(TERM)을 보냅니다.
- **예시**: `kill 1234` (PID 1234인 프로세스에 종료 요청)
- `kill -9 [PID]`: 지정된 PID의 프로세스를 강제로 종료합니다. (SIGKILL 시그널, 프로세스가 무시할 수 없음)
- **예시**: `kill -9 1234` (PID 1234인 프로세스를 강제 종료)
- `kill -15 [PID]`: 지정된 PID의 프로세스에 정상 종료 시그널(SIGTERM)을 보냅니다. (프로세스가 정리 작업을 수행할 수 있음)
- **예시**: `kill -15 1234` (PID 1234인 프로세스에 정상 종료 요청)

### `killall`
프로세스 이름으로 모든 해당 프로세스를 종료합니다.
- `killall [프로세스명]`: 지정된 이름의 모든 프로세스에 종료 시그널을 보냅니다.
- **예시**: `killall firefox` (모든 Firefox 브라우저 프로세스 종료)
- `killall -9 [프로세스명]`: 지정된 이름의 모든 프로세스를 강제로 종료합니다.
- **예시**: `killall -9 firefox` (모든 Firefox 브라우저 프로세스 강제 종료)

### `pkill`
프로세스 이름 또는 다른 속성으로 프로세스를 찾아 시그널을 보냅니다. `killall`보다 더 유연합니다.
- `pkill -9 firefox`: 모든 Firefox 프로세스를 강제로 종료합니다.
- **예시**: `pkill -u user1 chrome` (user1 사용자가 실행한 모든 Chrome 프로세스 종료)

### `nice` / `renice`
프로세스의 우선순위(Nice 값)를 변경합니다. Nice 값은 -20 (가장 높은 우선순위)부터 19 (가장 낮은 우선순위)까지 있습니다. 낮은 Nice 값은 CPU를 더 많이 할당받습니다.

- `nice -n [Nice값] [명령어]`: 지정된 Nice 값으로 명령어를 실행합니다.
    - **예시**: `nice -n 10 my_script.sh` (my_script.sh를 낮은 우선순위로 실행)
- `renice [Nice값] -p [PID]`: 실행 중인 프로세스의 Nice 값을 변경합니다.
    - **예시**: `renice -5 -p 1234` (PID 1234인 프로세스의 우선순위를 높임)

## 3. 백그라운드 및 포그라운드 프로세스

### `&` (앰퍼샌드)
명령어 뒤에 `&`를 붙이면 해당 명령어를 백그라운드에서 실행합니다.
- `my_long_command &`: `my_long_command`를 백그라운드에서 실행하고 터미널을 즉시 사용할 수 있게 합니다.
- **예시**: `sleep 60 &` (60초 동안 대기하는 명령어를 백그라운드에서 실행)

### `jobs`
현재 터미널에서 실행 중인 백그라운드 작업을 보여줍니다.
- **예시**: `jobs`
```bash
$ sleep 60 &
[1] 12345
$ jobs
[1]+  Running                 sleep 60 &
```

### `fg` (foreground)
백그라운드 작업을 포그라운드로 가져옵니다.
- `fg %1`: 첫 번째 백그라운드 작업을 포그라운드로 가져옵니다. (작업 번호는 `jobs`로 확인)
- **예시**: `fg %1` (첫 번째 백그라운드 작업을 포그라운드로 전환)

### `bg` (background)
정지된 포그라운드 작업을 백그라운드로 전환합니다.
- `Ctrl + Z`: 현재 포그라운드 작업을 일시 정지시킵니다.
- **예시**: `ping google.com` 실행 중 `Ctrl+Z` 누르기
```bash
$ ping google.com
^Z
[1]+  Stopped                 ping google.com
```
- `bg`: 일시 정지된 작업을 백그라운드에서 계속 실행합니다.
- **예시**: `bg` (일시 정지된 `ping` 작업을 백그라운드에서 재개)

### `nohup`
터미널이 종료되어도 프로세스가 계속 실행되도록 합니다.
- `nohup [명령어] &`: 명령어를 백그라운드에서 실행하고, 터미널이 닫혀도 프로세스가 종료되지 않도록 합니다. 출력은 `nohup.out` 파일에 저장됩니다.
- **예시**: `nohup ./my_long_running_script.sh &` (스크립트를 터미널 종료와 상관없이 백그라운드에서 실행)

프로세스 관리는 시스템 자원을 효율적으로 사용하고, 시스템의 안정성을 유지하는 데 매우 중요합니다. 위 명령어들을 통해 프로세스를 효과적으로 모니터링하고 제어할 수 있습니다.
[AD]