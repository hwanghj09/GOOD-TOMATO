# 동적 프로그래밍 (Dynamic Programming, DP)

동적 프로그래밍은 복잡한 문제를 간단한 여러 개의 하위 문제(Subproblem)로 나누어 풀고, 그 결과를 저장하여 동일한 하위 문제가 다시 발생했을 때 저장된 결과를 재사용함으로써 계산 횟수를 줄이는 알고리즘 설계 기법입니다.

## 핵심 조건

DP를 적용하려면 문제가 다음 두 가지 속성을 만족해야 합니다.

1.  **최적 부분 구조 (Optimal Substructure):** 문제의 최적해가 그 하위 문제들의 최적해로부터 구해질 수 있어야 합니다.
2.  **중복되는 하위 문제 (Overlapping Subproblems):** 동일한 하위 문제가 반복적으로 나타나야 합니다. DP는 이 중복 계산을 피함으로써 효율을 높입니다.

## 접근 방식

-   **메모이제이션 (Memoization - Top-down):** 재귀 호출을 기반으로, 한 번 계산한 하위 문제의 결과를 배열이나 해시 테이블에 저장합니다. 다음에 같은 문제가 나오면 계산하지 않고 저장된 값을 반환합니다.
-   **타뷸레이션 (Tabulation - Bottom-up):** 반복문을 기반으로, 가장 작은 하위 문제부터 시작하여 차례대로 문제의 크기를 키워가며 최종 문제의 답을 구합니다.

## 피보나치 수열 예시 (타뷸레이션)

피보나치 수열은 `F(n) = F(n-1) + F(n-2)`로 정의되며, `F(n)`을 구하기 위해 `F(n-1)`과 `F(n-2)`가 반복적으로 계산되는 중복 하위 문제 구조를 가집니다.

```python
def fibonacci_dp(n):
    # 결과를 저장할 리스트(테이블) 생성
    dp_table = [0] * (n + 1)
    
    # 베이스 케이스 설정
    if n > 0:
        dp_table[1] = 1

    # 가장 작은 문제부터 차례로 해결
    for i in range(2, n + 1):
        dp_table[i] = dp_table[i-1] + dp_table[i-2]
        
    return dp_table[n]

# 테스트
print(f"피보나치 수(10): {fibonacci_dp(10)}") # 출력: 55
```